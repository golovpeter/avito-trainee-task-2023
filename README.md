# Сервис динамического сегментирования пользователей

`config.yaml` - минимальный файл конфигурации для базы данных и приложения

## Запуск приложения

**Для корректной работы сервиса необходимо указать пароль от базы данных в файле `config.yaml` и  `docker-compose.yaml`-
`postgres`.**
**Затем можно запустить сервис командой:**

```bash
docker compose up 
```

## Документанция

**После запуска сервиса вам станет доступна Swagger документация по адресу - http://localhost:8080/swagger/index.html**

**Предполагаю, что за работу с юзерами отвечает другой микросервис.**

**Методы:**

---

1. **Метод создания сегмента. Принимает slug (название) сегмента, и опционально процент пользователей, который
   обязательно попадут в этот сегмент.**

```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{
         "segment_slug": "AVITO_VOICE_MESSAGE"
         "percent_users": 50
}' \
http://localhost:8080/v1/segment/create
```

---

2. **Метод удаления сегмента. Принимает slug(название) сегмента. После удаления сегмента все пользователи с этим
   сегментом также удаляются.**

```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{
    "segment_slug": "AVITO_VOICE_MESSAGE"
}' \
http://localhost:8080/v1/segment/delete
```

---

3. **Метод добавления пользователя в сегмент. Принимает список slug (названий) сегментов которые нужно добавить
   пользователю, список slug (названий) сегментов которые нужно удалить у пользователя, id пользователя. Опционально
   принимает время, через которое нужно удалить пользователя из сегментов, в которые его добавляют.**

```bash
curl -X POST \
-H "Content-Type: application/json" \
-d '{
    "add_segments": [
        "AVITO_VOICE_MESSAGE"
    ],
    "delete_segments": [
        "AVITO_DISCOUNT_30"
    ],
    "user_id": 1003,
    "expired_at": "2023-09-22T23:41:00Z"
}' \
http://localhost:8080/v1/segment/changeForUser
```

**Решение по валидации:**

- **Если добавляемые и удаляемые сегменты имеют пересечение - возвращается ответ с кодом 400, и список пересекающихся
  сегментов**

- **Если какой-либо сегмент не найден в одном из списков - возвращается ответ с кодом 400, и список с ненайденнными
  сегментами**

---

4. **Метод получения активных сегментов пользователя. Принимает на вход id пользователя.**

```bash
curl -X GET \
http://localhost:8080/v1/segments/user/1000 \
-H "accept: application/json" 
```

## Дополнительные задания:

1. **Сохранение истории попадания/выбывания пользователя из сегмента с возможностью получения отчета**.

   До конца реализовать не удалось. Успел добавить только триггер в базу данных на
   удаления и создания сегментов у пользователей, но хотел бы описать логику, которая могла бы быть использована:
    - Создаём триггер в базе данных на удаление и добавление сегментов у пользоваталей
    - Создаём еще дополнительные эндпоинт, который выполняет 2 задачи:
        + Возвращается ссылку на будущий файл или уже на существующий файл.
        + Добавляет задачу в очередь, если файл не существует.
    - Создаём воркер, который бы смотрел, существует ли файл с таким названием (датой, месяцем). Если такой файл уже
      существует - удаляет задачу из очереди, иначе генерирует файл, при этом запрашивая историю бачами из базы.
    - Созданные файлы храним в контейнере, но при масштабировании придется использовать внешнее хранилище, как пример - S3.
    - Создаём еще один эндпоинт, на который отдаётся ссылка в первом. Если файл еще не готов, будем возвращаться
      сообщение об этом.

---

2. **Возможность задавать время нахождения пользователя в сегменте.**

   Реализовано. В методе добавления сегментов можно опционально указать дату, до которой пользователь будет находиться в
   этих
   сегментах. При старте приложения в отдельном контейнере запускается воркер, который с определенным интервалом
   проверяет, не истек ли срок нахождения пользователя в сегменте, в противном случае он удаляет его из этого сегмента.

---

3. **Автоматическое попадание пользователей в сегмент.**

   Реализовано. В методе создания сегмента есть возможность опционально передать процент пользователей, которе должны
   попасть в этот сегмент. Далее, после получения всех сегментов, мы из кэша получаем сегменты, в
   которые должны автоматически распределиться пользователи. Если пользователя еще нету в каком-то из этих сегментов, то
   случайным образом определяем, попадет он туда или нет.

   **Это задание можно было бы еще оптимизировать. Вместо определения случайным образом попадания пользователя в
   сегмент, можно было бы брать остаток от деления `user_id` на 100 и таким образом определять, попадает ли пользователь
   в
   автоматический сегмент или нет.**
   
    

